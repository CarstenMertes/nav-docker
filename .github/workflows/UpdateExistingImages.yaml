name: Update all existing images (Add a new layer)

on:
  workflow_dispatch:
    inputs:
      GenericTag:
        description: Generic Tag (leave empty to use value in generic/tag.txt)
        required: false
        default: ''
      BaseGenericTag:
        description: Base Generic Tag (leave empty to use latest)
        required: false
        default: ''
      PushToProd:
        description: Push to production (Y/N)
        required: false
        default: 'N'

permissions:
  contents: read

defaults:
  run:
    shell: PowerShell

env:
  resGroup: "buildgeneric"
  resLocation: "West Europe"
  machines: "5"
  ARMbranch: "dev"
  ARMtemplate: "buildagent"

jobs:
  AnalyzeImages:
    runs-on: [ windows-latest ]
    outputs:
      server2019: ${{ steps.Analyze.outputs.server2019 }}
      server2022: ${{ steps.Analyze.outputs.server2022 }}
      server2019filesOnly: ${{ steps.Analyze.outputs.server2019filesOnly }}
      server2022filesOnly: ${{ steps.Analyze.outputs.server2022filesOnly }}
    steps:
      - name: Analyze
        id: Analyze
        run: |
          $erroractionpreference = "STOP"
          try {
            $webclient = New-Object System.Net.WebClient
            $webclient.Headers.Add('Accept', "application/json")
            $url = "https://mcr.microsoft.com/v2/businesscentral/tags/list"
            $version = [System.Version]"0.0.0.0"
            $alltags = (($webclient.DownloadString("$url") | ConvertFrom-Json)).tags
            $versions = $alltags | Where-Object { [System.Version]::TryParse($_, [ref] $version) } | ForEach-Object { $version }
            $server2019 = @($versions | Where-Object { $_ -lt [System.Version]"10.0.17764.0" } | Sort-Object -Descending | ForEach-Object { "$_" } ) | ConvertTo-Json -compress
            $server2022 = @($versions | Where-Object { $_ -ge [System.Version]"10.0.17764.0" } | Sort-Object -Descending | ForEach-Object { "$_" } ) | ConvertTo-Json -compress
            $filesOnlyVersions = $alltags | Where-Object { $_ -like '*-filesonly' } | Where-Object { [System.Version]::TryParse($_.SubString(0,$_.Length-10), [ref] $version) } | ForEach-Object { $version }
            $server2019filesOnly = @($filesOnlyVersions | Where-Object { $_ -lt [System.Version]"10.0.17764.0" } | Sort-Object -Descending | ForEach-Object { "$_" } ) | ConvertTo-Json -compress
            $server2022filesOnly = @($filesOnlyVersions | Where-Object { $_ -ge [System.Version]"10.0.17764.0" } | Sort-Object -Descending | ForEach-Object { "$_" } ) | ConvertTo-Json -compress
            Write-Host "::set-output name=server2019::[$("$server2019".Trim('[]'))]"
            Write-Host "set-output name=server2019::[$("$server2019".Trim('[]'))]"
            Write-Host "::set-output name=server2022::[$("$server2022".Trim('[]'))]"
            Write-Host "set-output name=server2022::[$("$server2022".Trim('[]'))]"
            Write-Host "::set-output name=server2019filesOnly::[$("$server2019filesOnly".Trim('[]'))]"
            Write-Host "set-output name=server2019filesOnly::[$("$server2019filesOnly".Trim('[]'))]"
            Write-Host "::set-output name=server2022filesOnly::[$("$server2022filesOnly".Trim('[]'))]"
            Write-Host "set-output name=server2022filesOnly::[$("$server2022filesOnly".Trim('[]'))]"
          }
          catch {
            Write-Host "::Error::Error analyzing images. Error was $($_.Exception.Message)"
            $host.SetShouldExit(1)            
          }
  CreateAgents:
    runs-on: [ windows-latest ]
    needs: [ AnalyzeImages ]
    if: ${{ needs.AnalyzeImages.outputs.server2022count > 0 }}
    steps:
      - uses: actions/checkout@main

      - uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true 

      - name: Run Azure PowerShell script
        uses: azure/powershell@v1
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        with:
          azPSVersion: "latest"
          inlineScript: |
            $resGroup = $env:resGroup
            $resLocation = $env:resLocation
            $repo = $env:GITHUB_REPOSITORY
            $machines = [int]$env:machines
            Write-Host "Resource Group is $resGroup"
            $resourceGroup = Get-AzResourceGroup -name $resGroup -ErrorAction Ignore
            if ($resourceGroup) {
              Write-Host "Removing Resource Group $resGroup"
              Remove-AzResourceGroup -Name $resGroup -Force | Out-Host
              Write-Host "Done"
            }
            $runners = (gh api /repos/$repo/actions/runners | ConvertFrom-Json).runners
            $runners | Where-Object { $_.status -eq "offline" } | ForEach-Object {
              Write-host "Unregistering runner $($_.name)"
              $id = $_.id
              gh api -X DELETE /repos/$repo/actions/runners/$id
              Write-Host "Done"
            }
            Write-Host "Creating resource group $resGroup in $resLocation"
            $resourceGroup = New-AzResourceGroup -Name $resGroup -Location $resLocation -Force
            Write-Host "Done"
            1..$machines | ForEach-Object {
              # Deployment
              $no                       = $_

              # ARM template
              $templateUri = "https://raw.githubusercontent.com/microsoft/nav-arm-templates/$($env:ARMbranch)/$($env:ARMtemplate).json"

              $registrationToken = (gh api -X POST /repos/$repo/actions/runners/registration-token | ConvertFrom-Json).token
              $headers = @{ 
                "Accept"        = "application/json"
              }
              $uri = "https://api.github.com/repos/actions/runner/releases"
              $result = Invoke-WebRequest -UseBasicParsing -Headers $headers -Uri $uri
              $releases = $result.Content | ConvertFrom-Json
              $asset = $releases[0].assets | Where-Object {  $_.name -like "actions-runner-win-x64-*.*.?.zip" }

              $Parameters = @{
                "VmName"              = "$resgroup$no"
                "Remotedesktopaccess" = "-"
                "OperatingSystem"     = "Windows Server 2022"
                "VmSize"              = "Standard_D4as_v5"
                "OSDiskSize"          = 128
                "StorageAccountType"  = "Premium_LRS"
                "AdminPassword"       = [SecureString](ConvertTo-SecureString -String $env:GH_TOKEN -AsPlainText -Force)
                "Count"               = 1
                "Token"               = $registrationToken
                "Organization"        = "https://github.com/$repo"
                "LabelsOrPool"        = "buildgeneric"
                "AgentUrl"            = $asset.browser_download_url
                "InstallHyperV"       = "Yes"
                "RunInsideDocker"     = "No"
                "FinalSetupScriptUrl" = "additional-installforbuildagent.ps1"
              }

              $err = $resourceGroup | Test-AzResourceGroupDeployment -TemplateUri $templateUri -TemplateParameterObject $Parameters
              if ($err) {
                $err
                throw "stop"
              }
              Write-Host "Creating Azure VM $($parameters.VmName)"
              $resourceGroup | New-AzResourceGroupDeployment -TemplateUri $templateUri -TemplateParameterObject $Parameters -Name $Parameters.vmName -ErrorAction Ignore
              Write-Host "Done"
            }

  Server2019:
    runs-on: [ buildgeneric ]
    needs: [ AnalyzeImages, CreateAgents ]
    strategy:
      matrix:
        version: ${{fromJson(needs.AnalyzeImages.outputs.server2019)}}
      fail-fast: false
      max-parallel: 5
    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - name: Build Image
        run: |
          $filesOnlyStr = ""
          $baseGenericTag = '${{ github.event.inputs.BaseGenericTag }}'
          if ($baseGenericTag) { $baseGenericTag = "-$baseGenericTag" }
          $erroractionpreference = "STOP"
          Set-StrictMode -version 2.0
          try {
            $pushRegistry = "mcrbusinesscentral.azurecr.io"
            $job = start-job -ScriptBlock { Param($username, $token, $registry)
              Write-Output $token | docker login --username $username --password-stdin $registry
            } -ArgumentList '${{ secrets.PushUsername }}', '${{ secrets.PushToken }}', $pushRegistry
            $job | Wait-Job -ErrorAction SilentlyContinue -WarningAction SilentlyContinue | Out-Null
            $result = Receive-Job -ErrorAction SilentlyContinue -WarningAction SilentlyContinue $job 2> $NULL
            if ($result -ne 'Login Succeeded') {
              throw "docker login failed"
            }
            Set-Location "generic"
            $genericTag = '${{ github.event.inputs.GenericTag }}'
            if ($genericTag -eq '') { $genericTag = Get-Content -path 'tag.txt' }
            [System.Version]$genericTag | Out-Null
            $pushToProd = '${{ github.event.inputs.PushToProd }}' -eq 'Y'
            $osversion = '${{ matrix.version }}'
            $baseimage = "mcr.microsoft.com/businesscentral:$osversion$baseGenericTag$filesOnlyStr"
            $image = "my:$osversion-$genericTag$filesonlyStr"
            $created = [DateTime]::Now.ToUniversalTime().ToString("yyyyMMddHHmm")
            docker pull $baseimage
            $inspect = docker inspect $baseimage | ConvertFrom-Json
            $installdotnet6 = ""
            if ($baseGenericTag -eq "1.0.2.13") {
              $installdotnet6 = "RUN Invoke-WebRequest -Uri 'https://bcartifacts.blob.core.windows.net/prerequisites/dotnet-hosting-6.0.13-win.exe' -OutFile DotNet6-Win.exe ; \`n    start-process -Wait -FilePath .\DotNet6-Win.exe -ArgumentList /quiet ; \`n    Remove-Item -force DotNet6-Win.exe`n"
            }
            if ([version]$inspect.config.Labels.tag -ge [version]$generictag) {
              Write-Host "::Warning::Base Image is Generic Tag $($inspect.config.Labels.tag), skipping build of $osversion-$genericTag$filesonlyStr."
            }
            else {
              $dockerfile = Join-Path (Get-Location) "DOCKERFILE.UPDATE"
              "FROM $baseimage`nCOPY Run /Run/`n$($installdotnet6)LABEL tag=""$genericTag"" \`n      created=""$created""`n" | Set-Content $dockerfile
              $success = $false
              docker build --isolation=hyperv --tag $image --file $dockerfile --memory 4G (Get-Location) | % {
                $_ | Out-Host
                if ($_ -like "Successfully built*") {
                  $success = $true
                }
              }
              if (!$success) {
                throw "Error building image"
              }

              $newtags = @(
                "$pushRegistry/public/businesscentral:$osversion$filesonlyStr-dev"
              )
              if ($pushToProd) {
                $newtags += @(
                    "$pushRegistry/public/businesscentral:$osversion$filesonlyStr"
                    "$pushRegistry/public/businesscentral:$osversion-$genericTag$filesonlyStr"
                )
              }
              $newtags | ForEach-Object {
                Write-Host "Push $_"
                docker tag $image $_
                docker push $_
              }
            }
          }
          catch {
            Write-Host "::Error::Error building images. Error was $($_.Exception.Message)"
            $host.SetShouldExit(1)            
          }

  Server2022:
    runs-on: [ buildgeneric ]
    needs: [ AnalyzeImages, CreateAgents ]
    strategy:
      matrix:
        version: ${{fromJson(needs.AnalyzeImages.outputs.server2022)}}
      fail-fast: false
      max-parallel: 5
    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - name: Build Image
        run: |
          $filesOnlyStr = ""
          $baseGenericTag = '${{ github.event.inputs.BaseGenericTag }}'
          if ($baseGenericTag) { $baseGenericTag = "-$baseGenericTag" }
          $erroractionpreference = "STOP"
          Set-StrictMode -version 2.0
          try {
            $pushRegistry = "mcrbusinesscentral.azurecr.io"
            $job = start-job -ScriptBlock { Param($username, $token, $registry)
              Write-Output $token | docker login --username $username --password-stdin $registry
            } -ArgumentList '${{ secrets.PushUsername }}', '${{ secrets.PushToken }}', $pushRegistry
            $job | Wait-Job -ErrorAction SilentlyContinue -WarningAction SilentlyContinue | Out-Null
            $result = Receive-Job -ErrorAction SilentlyContinue -WarningAction SilentlyContinue $job 2> $NULL
            if ($result -ne 'Login Succeeded') {
              throw "docker login failed"
            }
            Set-Location "generic"
            $genericTag = '${{ github.event.inputs.GenericTag }}'
            if ($genericTag -eq '') { $genericTag = Get-Content -path 'tag.txt' }
            [System.Version]$genericTag | Out-Null
            $pushToProd = '${{ github.event.inputs.PushToProd }}' -eq 'Y'
            $osversion = '${{ matrix.version }}'
            $baseimage = "mcr.microsoft.com/businesscentral:$osversion$baseGenericTag$filesOnlyStr"
            $image = "my:$osversion-$genericTag$filesonlyStr"
            $created = [DateTime]::Now.ToUniversalTime().ToString("yyyyMMddHHmm")
            docker pull $baseimage
            $inspect = docker inspect $baseimage | ConvertFrom-Json
            $installdotnet6 = ""
            if ($baseGenericTag -eq "1.0.2.13") {
              $installdotnet6 = "RUN Invoke-WebRequest -Uri 'https://bcartifacts.blob.core.windows.net/prerequisites/dotnet-hosting-6.0.13-win.exe' -OutFile DotNet6-Win.exe ; \`n    start-process -Wait -FilePath .\DotNet6-Win.exe -ArgumentList /quiet ; \`n    Remove-Item -force DotNet6-Win.exe`n"
            }
            if ([version]$inspect.config.Labels.tag -ge [version]$generictag) {
              Write-Host "::Warning::Base Image is Generic Tag $($inspect.config.Labels.tag), skipping build of $osversion-$genericTag$filesonlyStr."
            }
            else {
              $dockerfile = Join-Path (Get-Location) "DOCKERFILE.UPDATE"
              "FROM $baseimage`nCOPY Run /Run/`n$($installdotnet6)LABEL tag=""$genericTag"" \`n      created=""$created""`n" | Set-Content $dockerfile
              $success = $false
              docker build --isolation=hyperv --tag $image --file $dockerfile --memory 4G (Get-Location) | % {
                $_ | Out-Host
                if ($_ -like "Successfully built*") {
                  $success = $true
                }
              }
              if (!$success) {
                throw "Error building image"
              }

              $newtags = @(
                "$pushRegistry/public/businesscentral:$osversion$filesonlyStr-dev"
              )
              if ($pushToProd) {
                $newtags += @(
                    "$pushRegistry/public/businesscentral:$osversion$filesonlyStr"
                    "$pushRegistry/public/businesscentral:$osversion-$genericTag$filesonlyStr"
                )
              }
              $newtags | ForEach-Object {
                Write-Host "Push $_"
                docker tag $image $_
                docker push $_
              }
            }
          }
          catch {
            Write-Host "::Error::Error building images. Error was $($_.Exception.Message)"
            $host.SetShouldExit(1)            
          }

  Server2019filesOnly:
    runs-on: [ windows-2019 ]
    needs: [ AnalyzeImages, CreateAgents ]
    strategy:
      matrix:
        version: ${{fromJson(needs.AnalyzeImages.outputs.server2019filesOnly)}}
      fail-fast: false
      max-parallel: 5
    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - name: Build Image
        run: |
          $filesOnlyStr = "-filesonly"
          $baseGenericTag = '${{ github.event.inputs.BaseGenericTag }}'
          if ($baseGenericTag) { $baseGenericTag = "-$baseGenericTag" }
          $erroractionpreference = "STOP"
          Set-StrictMode -version 2.0
          try {
            $pushRegistry = "mcrbusinesscentral.azurecr.io"
            $job = start-job -ScriptBlock { Param($username, $token, $registry)
              Write-Output $token | docker login --username $username --password-stdin $registry
            } -ArgumentList '${{ secrets.PushUsername }}', '${{ secrets.PushToken }}', $pushRegistry
            $job | Wait-Job -ErrorAction SilentlyContinue -WarningAction SilentlyContinue | Out-Null
            $result = Receive-Job -ErrorAction SilentlyContinue -WarningAction SilentlyContinue $job 2> $NULL
            if ($result -ne 'Login Succeeded') {
              throw "docker login failed"
            }
            Set-Location "generic"
            $genericTag = '${{ github.event.inputs.GenericTag }}'
            if ($genericTag -eq '') { $genericTag = Get-Content -path 'tag.txt' }
            [System.Version]$genericTag | Out-Null
            $pushToProd = '${{ github.event.inputs.PushToProd }}' -eq 'Y'
            $osversion = '${{ matrix.version }}'
            $baseimage = "mcr.microsoft.com/businesscentral:$osversion$baseGenericTag$filesOnlyStr"
            $image = "my:$osversion-$genericTag$filesonlyStr"
            $created = [DateTime]::Now.ToUniversalTime().ToString("yyyyMMddHHmm")
            docker pull $baseimage
            $inspect = docker inspect $baseimage | ConvertFrom-Json
            if ([version]$inspect.config.Labels.tag -ge [version]$generictag) {
              Write-Host "::Warning::Base Image is Generic Tag $($inspect.config.Labels.tag), skipping build of $osversion-$genericTag$filesonlyStr."
            }
            else {
              $dockerfile = Join-Path (Get-Location) "DOCKERFILE.UPDATE"
              "FROM $baseimage`nCOPY Run /Run/`nLABEL tag=""$genericTag"" \`n      created=""$created""`n" | Set-Content $dockerfile
              $success = $false
              docker build --isolation=hyperv --tag $image --file $dockerfile --memory 4G (Get-Location) | % {
                $_ | Out-Host
                if ($_ -like "Successfully built*") {
                  $success = $true
                }
              }
              if (!$success) {
                throw "Error building image"
              }

              $newtags = @(
                "$pushRegistry/public/businesscentral:$osversion$filesonlyStr-dev"
              )
              if ($pushToProd) {
                $newtags += @(
                    "$pushRegistry/public/businesscentral:$osversion$filesonlyStr"
                    "$pushRegistry/public/businesscentral:$osversion-$genericTag$filesonlyStr"
                )
              }
              $newtags | ForEach-Object {
                Write-Host "Push $_"
                docker tag $image $_
                docker push $_
              }
            }
          }
          catch {
            Write-Host "::Error::Error building images. Error was $($_.Exception.Message)"
            $host.SetShouldExit(1)            
          }

  Server2022filesOnly:
    runs-on: [ windows-2022 ]
    needs: [ AnalyzeImages, CreateAgents ]
    strategy:
      matrix:
        version: ${{fromJson(needs.AnalyzeImages.outputs.server2022filesOnly)}}
      fail-fast: false
      max-parallel: 5
    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - name: Build Image
        run: |
          $filesOnlyStr = "-filesonly"
          $baseGenericTag = '${{ github.event.inputs.BaseGenericTag }}'
          if ($baseGenericTag) { $baseGenericTag = "-$baseGenericTag" }
          $erroractionpreference = "STOP"
          Set-StrictMode -version 2.0
          try {
            $pushRegistry = "mcrbusinesscentral.azurecr.io"
            $job = start-job -ScriptBlock { Param($username, $token, $registry)
              Write-Output $token | docker login --username $username --password-stdin $registry
            } -ArgumentList '${{ secrets.PushUsername }}', '${{ secrets.PushToken }}', $pushRegistry
            $job | Wait-Job -ErrorAction SilentlyContinue -WarningAction SilentlyContinue | Out-Null
            $result = Receive-Job -ErrorAction SilentlyContinue -WarningAction SilentlyContinue $job 2> $NULL
            if ($result -ne 'Login Succeeded') {
              throw "docker login failed"
            }
            Set-Location "generic"
            $genericTag = '${{ github.event.inputs.GenericTag }}'
            if ($genericTag -eq '') { $genericTag = Get-Content -path 'tag.txt' }
            [System.Version]$genericTag | Out-Null
            $pushToProd = '${{ github.event.inputs.PushToProd }}' -eq 'Y'
            $osversion = '${{ matrix.version }}'
            $baseimage = "mcr.microsoft.com/businesscentral:$osversion$baseGenericTag$filesOnlyStr"
            $image = "my:$osversion-$genericTag$filesonlyStr"
            $created = [DateTime]::Now.ToUniversalTime().ToString("yyyyMMddHHmm")
            docker pull $baseimage
            $inspect = docker inspect $baseimage | ConvertFrom-Json
            if ([version]$inspect.config.Labels.tag -ge [version]$generictag) {
              Write-Host "::Warning::Base Image is Generic Tag $($inspect.config.Labels.tag), skipping build of $osversion-$genericTag$filesonlyStr."
            }
            else {
              $dockerfile = Join-Path (Get-Location) "DOCKERFILE.UPDATE"
              "FROM $baseimage`nCOPY Run /Run/`nLABEL tag=""$genericTag"" \`n      created=""$created""`n" | Set-Content $dockerfile
              $success = $false
              docker build --isolation=hyperv --tag $image --file $dockerfile --memory 4G (Get-Location) | % {
                $_ | Out-Host
                if ($_ -like "Successfully built*") {
                  $success = $true
                }
              }
              if (!$success) {
                throw "Error building image"
              }

              $newtags = @(
                "$pushRegistry/public/businesscentral:$osversion$filesonlyStr-dev"
              )
              if ($pushToProd) {
                $newtags += @(
                    "$pushRegistry/public/businesscentral:$osversion$filesonlyStr"
                    "$pushRegistry/public/businesscentral:$osversion-$genericTag$filesonlyStr"
                )
              }
              $newtags | ForEach-Object {
                Write-Host "Push $_"
                docker tag $image $_
                docker push $_
              }
            }
          }
          catch {
            Write-Host "::Error::Error building images. Error was $($_.Exception.Message)"
            $host.SetShouldExit(1)            
          }

  RemoveAgents:
    runs-on: [ windows-latest ]
    needs: [ AnalyzeImages, CreateAgents, Server2019, Server2019filesOnly, Server2022, Server2022filesOnly ]
    steps:
      - uses: actions/checkout@main

      - uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true 

      - name: Run Azure PowerShell script
        uses: azure/powershell@v1
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        with:
          azPSVersion: "latest"
          inlineScript: |
            $resGroup = $env:resGroup
            $resLocation = $env:resLocation
            $repo = $env:GITHUB_REPOSITORY
            Write-Host "Resource Group is $resGroup"
            $resourceGroup = Get-AzResourceGroup -name $resGroup -ErrorAction Ignore
            if ($resourceGroup) {
              Write-Host "Removing Resource Group $resGroup"
              Remove-AzResourceGroup -Name $resGroup -Force | Out-Host
              Write-Host "Done"
            }
            $runners = (gh api /repos/$repo/actions/runners | ConvertFrom-Json).runners
            $runners | Where-Object { $_.status -eq "offline" } | ForEach-Object {
              Write-host "Unregistering runner $($_.name)"
              $id = $_.id
              gh api -X DELETE /repos/$repo/actions/runners/$id
              Write-Host "Done"
            }
